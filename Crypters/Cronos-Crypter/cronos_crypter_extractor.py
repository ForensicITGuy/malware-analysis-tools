from Crypto.Cipher import AES
from Crypto.Protocol import KDF
from dotnetfile import DotNetPE
from base64 import b64decode
import argparse

# Derived from https://github.com/RussianPanda95/Configuration_extractors/blob/main/AsyncRAT_config_extractor
# Derived from https://research.openanalysis.net/dot%20net/static%20analysis/stormkitty/dnlib/python/research/2021/07/14/dot_net_static_analysis.html 

parser = argparse.ArgumentParser()
parser.add_argument("-f", "--file", help="path of the binary file", required=True)
parser.add_argument("-o", "--output", help="path of output file", required=True)
args = parser.parse_args()

def decrypt(ciphertext, key, iv):
    cipher = AES.new(key, AES.MODE_CBC, iv)
    return cipher.decrypt(ciphertext)

dotnet_file_path = args.file
dotnet_file = DotNetPE(dotnet_file_path)
data = dotnet_file.get_user_stream_strings()

# The second base64 user string always seems to be the encryption key
cronos_key = b64decode(data[1])

# Cronos-Crypter protected files always seem to have just one .NET resource
encrypted_resource = dotnet_file.get_resources()[0]["Data"]

# Salt from https://github.com/TalosSec/Cronos-Crypter/blob/2b531140b8c67953b4ee8942f8ea8dc5389e7b8c/CronosCrypter/Resources/Stub.cs#L109C47-L109C85
salt = bytes([26, 20, 202, 234, 136, 123, 69, 47])
password = bytes(cronos_key)
iter_count = 1000
key_size = 256
block_size = 128
key_size_bytes = int(key_size/8)
block_size_bytes = int(block_size/8)
# Generate the key and IV from the hard coded password and salt

# Rfc2898DeriveBytes is a streaming-response object, 
# so concatenating two successive calls is the same as 
# doing one call with both lengths added together

key_bytes = KDF.PBKDF2(password, salt, count=iter_count, dkLen=key_size_bytes+block_size_bytes)
cleartext_resource = decrypt(encrypted_resource,key_bytes[:key_size_bytes], key_bytes[key_size_bytes:])

with open(args.output, "wb") as output_file:
    output_file.write(cleartext_resource)